#!/usr/bin/env node
/**
 * Cleanup Command - Refactored Version
 * 
 * Removes all published events from relays using the new modular architecture.
 */

import path from "node:path";
import dotenv from "dotenv";
import { stdin as input, stdout as output } from "node:process";
import * as readline from "node:readline/promises";

// Import refactored utilities
import { EVENT_KINDS, EXIT_CODES, FILES } from "../lib/constants.mjs";
import { getPrivateKey, getPublicKeyFromPrivate } from "../lib/keypair.mjs";
import { 
  connectToRelay, 
  closeRelay, 
  queryEvents, 
  parseRelayUrls 
} from "../lib/relay.mjs";
import { 
  createDeletionEvent, 
  groupEventsByKind, 
  getEventId 
} from "../lib/events.mjs";
import { logger } from "../utils/logger.mjs";
import { handleError, ConfigError, NetworkError } from "../utils/errors.mjs";
import { deleteFile } from "../utils/fs.mjs";
import { nip19 } from "nostr-tools";

dotenv.config();

/**
 * Query all events from a relay
 * 
 * @param {string} relayUrl - Relay URL
 * @param {string} pubkey - Author public key
 * @returns {Promise<Array>} Array of events
 */
async function queryAllEvents(relayUrl, pubkey) {
  try {
    const relay = await connectToRelay(relayUrl);
    
    const kinds = [
      EVENT_KINDS.ASSET,
      EVENT_KINDS.MANIFEST,
      EVENT_KINDS.SITE_INDEX,
      EVENT_KINDS.ENTRYPOINT,
    ];

    const events = await queryEvents(relay, [{ kinds, authors: [pubkey] }]);
    closeRelay(relay);
    
    return events;
  } catch (error) {
    logger.warn(`Failed to query ${relayUrl}: ${error.message}`);
    return [];
  }
}

/**
 * Delete events from a relay
 * 
 * @param {string} relayUrl - Relay URL
 * @param {Array<string>} eventIds - Event IDs to delete
 * @param {string} skHex - Private key
 * @returns {Promise<Object>} Deletion results
 */
async function deleteEventsFromRelay(relayUrl, eventIds, skHex) {
  if (eventIds.length === 0) {
    return { published: 0, failed: 0 };
  }

  let published = 0;
  let failed = 0;

  try {
    const relay = await connectToRelay(relayUrl);

    // Create deletion events in batches
    const batchSize = 10;
    for (let i = 0; i < eventIds.length; i += batchSize) {
      const batch = eventIds.slice(i, i + batchSize);
      const deleteEvent = createDeletionEvent(batch, "Cleanup", skHex);

      try {
        await relay.publish(deleteEvent);
        published += batch.length;
        process.stdout.write(".");
      } catch (error) {
        failed += batch.length;
        process.stdout.write("âœ—");
      }
    }

    closeRelay(relay);
  } catch (error) {
    logger.warn(`Failed to delete from ${relayUrl}: ${error.message}`);
    failed = eventIds.length - published;
  }

  return { published, failed };
}

/**
 * Display events summary
 * 
 * @param {Map<string, Array>} relayEvents - Map of relay URL to events
 */
function displayEventsSummary(relayEvents) {
  logger.info("\nðŸ“‹ Events to be deleted:\n");

  for (const [url, events] of relayEvents) {
    if (events.length === 0) {
      logger.info(`${url}: No events found`);
      continue;
    }

    const grouped = groupEventsByKind(events);
    logger.info(`${url}: ${events.length} events`);

    for (const [kind, kindEvents] of grouped) {
      const kindName = getKindName(kind);
      logger.info(`   - ${kindName}: ${kindEvents.length}`);
    }
  }

  logger.info("");
}

/**
 * Get friendly name for event kind
 * 
 * @param {number} kind - Event kind
 * @returns {string} Kind name
 */
function getKindName(kind) {
  const names = {
    [EVENT_KINDS.ASSET]: "Assets",
    [EVENT_KINDS.MANIFEST]: "Manifests",
    [EVENT_KINDS.SITE_INDEX]: "Site Index",
    [EVENT_KINDS.ENTRYPOINT]: "Entrypoint",
  };
  return names[kind] || `Kind ${kind}`;
}

/**
 * Main cleanup function
 * 
 * @param {string} siteDir - Site directory path
 */
async function cleanup(siteDir = null) {
  try {
    // Load configuration
    const skHex = getPrivateKey(siteDir);
    const pubkey = getPublicKeyFromPrivate(skHex);
    const npub = nip19.npubEncode(pubkey);

    const relayList = process.env.RELAYS || process.env.NOSTR_RELAYS;
    if (!relayList) {
      throw new ConfigError("RELAYS not configured in .env");
    }
    const relays = parseRelayUrls(relayList);

    if (relays.length === 0) {
      throw new ConfigError("No valid relay URLs found");
    }

    // Display header
    logger.header("ðŸ§¹ Nostr Web Cleanup Tool");
    logger.info(`ðŸ”‘ Identity: ${npub}\n`);
    logger.info(`ðŸ”Œ Configured relays: ${relays.length}\n`);

    // Query all relays
    logger.info("ðŸ” Querying relays for events...\n");

    const relayEvents = new Map();
    let totalEvents = 0;

    for (const url of relays) {
      process.stdout.write(`   Querying ${url}... `);
      const events = await queryAllEvents(url, pubkey);
      relayEvents.set(url, events);
      totalEvents += events.length;
      console.log(`${events.length} events`);
    }

    logger.info("");

    // Check if any events found
    if (totalEvents === 0) {
      logger.info("âœ… No events found on any relay.\n");
      logger.info("   Your site is not currently published.\n");
      return;
    }

    // Display summary
    displayEventsSummary(relayEvents);

    logger.separator();
    logger.warn(`âš ï¸  Total events to delete: ${totalEvents}`);
    logger.warn(`   ${relays.length} relay(s) will be cleaned\n`);

    // Confirmation prompt
    const rl = readline.createInterface({ input, output });
    const confirmation = await rl.question('Type "DELETE" to confirm: ');
    rl.close();

    if (confirmation !== "DELETE") {
      logger.info("\nâŒ Cleanup cancelled.\n");
      return;
    }

    // Delete events
    logger.info("\nðŸ—‘ï¸  Deleting events...\n");

    const deletionResults = new Map();

    for (const [url, events] of relayEvents) {
      if (events.length === 0) continue;

      process.stdout.write(`   ${url}: `);
      const eventIds = events.map(getEventId);
      const result = await deleteEventsFromRelay(url, eventIds, skHex);
      deletionResults.set(url, result);
      console.log(` ${result.published}/${eventIds.length} deleted`);
    }

    // Delete cache file if site directory provided
    if (siteDir) {
      const cachePath = path.join(siteDir, FILES.CACHE);
      if (deleteFile(cachePath)) {
        logger.debug(`Deleted cache file: ${cachePath}`);
      }
    }

    // Summary
    logger.info("");
    logger.separator();
    logger.info("ðŸ“Š CLEANUP SUMMARY");
    logger.separator();
    logger.info("");

    const totalDeleted = Array.from(deletionResults.values())
      .reduce((sum, r) => sum + r.published, 0);
    const totalFailed = Array.from(deletionResults.values())
      .reduce((sum, r) => sum + r.failed, 0);

    logger.success(`Deleted: ${totalDeleted} events`);
    if (totalFailed > 0) {
      logger.error(`Failed: ${totalFailed} events`);
    }
    logger.info(`ðŸ“¡ Relays cleaned: ${deletionResults.size}/${relays.length}`);
    logger.info("");
    logger.separator();
    logger.info("");

    if (totalFailed === 0) {
      logger.success("Cleanup complete!\n");
    } else {
      logger.warn("Cleanup completed with some failures.\n");
      logger.info("Run cleanup again to retry failed deletions.\n");
    }

  } catch (error) {
    handleError(error);
  }
}

/**
 * Main entry point
 */
async function main() {
  const args = process.argv.slice(2);

  // Show help
  if (args.includes("--help") || args.includes("-h")) {
    console.log(`
ðŸ§¹ Nostr Web Cleanup Tool

Remove all published events from Nostr relays.

Usage: nweb cleanup [site-folder]

Examples:
  # Cleanup using .env keypair
  nweb cleanup
  
  # Cleanup specific site
  nweb cleanup ./my-site

What it does:
  1. Queries all events (kinds 1125, 1126, 31126, 11126)
  2. Shows summary of events to be deleted
  3. Asks for confirmation (type "DELETE")
  4. Sends kind 5 deletion events to all relays
  5. Deletes local cache file
  6. Shows deletion statistics per relay

Use cases:
  - Reset site for fresh deployment
  - Remove test data
  - Fix corrupted state
  - Clean up before major refactor
`);
    return;
  }

  // Get site directory from args
  const siteDir = args[0] || null;

  await cleanup(siteDir);
}

// Run with error handling
main().catch((error) => {
  handleError(error);
});
